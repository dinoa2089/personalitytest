#!/usr/bin/env node
/**
 * Update mock questions with fixed versions
 * This updates the mock-questions.ts file for local development
 */

const fs = require('fs');
const path = require('path');

const fixedPath = path.join(__dirname, 'generated-questions-fixed.json');
const outputPath = path.join(__dirname, '..', 'lib', 'mock-questions.ts');

console.log('ðŸ“ Updating mock questions with fixed versions...\n');

if (!fs.existsSync(fixedPath)) {
  console.error('âŒ generated-questions-fixed.json not found');
  console.log('   Run: node scripts/fix-duplicate-questions.js first');
  process.exit(1);
}

const fixed = JSON.parse(fs.readFileSync(fixedPath, 'utf-8'));
console.log(`ðŸ“‹ Loaded ${fixed.length} fixed questions\n`);

// Build the TypeScript file
let output = `/**
 * Mock question data for development/testing when Supabase is not available
 * Updated with fixed unique question texts (no duplicate forced-choice questions)
 * Generated by scripts/update-mock-questions.js
 */
import type { Question, ForcedChoiceOption } from "@/types";

export const mockQuestions: Question[] = [\n`;

// Format each question
fixed.forEach((q, idx) => {
  output += '  {\n';
  output += `    id: "mock-${q.dimension}-${idx + 1}",\n`;
  output += `    text: ${JSON.stringify(q.text)},\n`;
  output += `    type: "${q.type}",\n`;
  output += `    dimension: "${q.dimension}",\n`;
  
  if (q.options) {
    if (q.type === 'forced_choice') {
      output += `    options: [\n`;
      q.options.forEach((opt, i) => {
        if (typeof opt === 'object') {
          output += `      { text: ${JSON.stringify(opt.text)}, dimension: "${opt.dimension}" }`;
        } else {
          output += `      ${JSON.stringify(opt)}`;
        }
        output += i < q.options.length - 1 ? ',\n' : '\n';
      });
      output += `    ] as ForcedChoiceOption[],\n`;
    } else {
      output += `    options: ${JSON.stringify(q.options)},\n`;
    }
  }
  
  output += `    reverse_scored: ${q.reverse_scored || false},\n`;
  output += `    weight: ${q.weight || 1.0},\n`;
  output += `    discrimination: ${q.discrimination || 1.0},\n`;
  
  if (q.framework_tags && q.framework_tags.length > 0) {
    output += `    framework_tags: ${JSON.stringify(q.framework_tags)},\n`;
  }
  
  if (q.is_core) {
    output += `    is_core: true,\n`;
  }
  
  output += '  },\n';
});

output += '];\n';

// Write the file
fs.writeFileSync(outputPath, output);

console.log(`âœ… Updated ${outputPath}`);
console.log(`   Total questions: ${fixed.length}`);

// Show breakdown
const byDimension = {};
const byType = {};

fixed.forEach(q => {
  byDimension[q.dimension] = (byDimension[q.dimension] || 0) + 1;
  byType[q.type] = (byType[q.type] || 0) + 1;
});

console.log('\nðŸ“Š By dimension:');
Object.entries(byDimension).sort().forEach(([dim, count]) => {
  console.log(`   ${dim}: ${count}`);
});

console.log('\nðŸ“Š By type:');
Object.entries(byType).sort().forEach(([type, count]) => {
  console.log(`   ${type}: ${count}`);
});

console.log('\nðŸŽ‰ Done! Mock questions are now updated.');
console.log('   Run: npm run dev to test the assessment');


